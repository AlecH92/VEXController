#pragma config(UART_Usage, UART1, uartUserControl, baudRate38400, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rearRight,     tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_5)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_4)
#pragma config(Motor,  port3,           rearLeft,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           frontLeft,     tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_3)
#pragma config(Motor,  port9,           theClaw,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          theArm,        tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int batteryv = 0;
int btx = 0;
int bty = 0;
int btx2 = 0;
int bty2 = 0;

void drive(int y, int x, int spin) {
    motor[frontRight] = y - x - spin;
    motor[rearRight] =  y - x + spin;
    motor[frontLeft] = y + x + spin;
    motor[rearLeft] =  y + x - spin;
}

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

/* --------------------------- PID BEGIN --------------------------- */

#define PID_SENSOR_INDEX    I2C_1
#define PID_SENSOR_SCALE    1
#define PID_MOTOR_INDEX     theArm
#define PID_MOTOR_SCALE     -1
#define PID_DRIVE_MAX       70
#define PID_DRIVE_MIN     (-20)
#define PID_INTEGRAL_LIMIT  50
float  pid_Kp = 2.0;
float  pid_Ki = 0.04;
float  pid_Kd = 0.0;
static int   pidRunning = 1;
static float pidRequestedValue;

task pidController() {
	float  pidSensorCurrentValue;
	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidDrive;
	nMotorEncoder[theArm] = 0;
	pidLastError  = 0;
	pidIntegral   = 0;
	while(true) {
		if( pidRunning ) {
			pidSensorCurrentValue = SensorValue[ PID_SENSOR_INDEX ] * PID_SENSOR_SCALE;
			pidError = pidSensorCurrentValue - pidRequestedValue;
			if( pid_Ki != 0 ) {
				if( abs(pidError) < PID_INTEGRAL_LIMIT ) {
					pidIntegral = pidIntegral + pidError;
				}
				else {
					pidIntegral = 0;
				}
			}
			else {
				pidIntegral = 0;
			}
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;
			pidDrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);
			if( pidDrive > PID_DRIVE_MAX ) {
				pidDrive = PID_DRIVE_MAX;
			}
			if( pidDrive < PID_DRIVE_MIN ) {
				pidDrive = PID_DRIVE_MIN;
			}
			motor[PID_MOTOR_INDEX] = (pidDrive * PID_MOTOR_SCALE)*-1;
		}
		else
		{
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			motor[PID_MOTOR_INDEX] = 0;
		}
		wait1Msec(25);
	}
}

/* --------------------------- PID END --------------------------- */

int rcvChar;
long lastTime = 0;

task main() {
	pidRequestedValue = 0;
	startTask(pidController);
	while (true) {
		batteryv = nImmediateBatteryLevel;
    rcvChar = getChar(uartOne);
    if (rcvChar == -1) {
      wait1Msec(2);
      continue;
    }
		else { //if we got something, and it's been 1s since last battery update, send update
			if(nSysTime - lastTime > 1000) {
				batteryv = map(batteryv, 0, 8000, 0, 255);
				sendChar(uartOne, batteryv);
				lastTime = nSysTime;
			}
		}

    if(rcvChar == 1) { //forward
    	drive(127,0,0);
    }
    if(rcvChar == 2) { //diagonal to the front+left
    	motor[frontRight] = 127;
    	motor[rearLeft] = 127;
    }
    if(rcvChar == 3) { //rotate left
    	drive(0,127,0);
    }
    if(rcvChar == 4) { //diagonal to the reverse+left
    	motor[frontLeft] = -127;
    	motor[rearRight] = -127;
    }
    if(rcvChar == 5) { //reverse
    	drive(-127,0,0);
    }
    if(rcvChar == 6) { //diagonal to the reverse+right
    	motor[frontRight] = -127;
    	motor[rearLeft] = -127;
    }
    if(rcvChar == 7) { //rotate right
    	drive(0,-127,0);
    }
    if(rcvChar == 8) { //diagonal to the forward+right
    	motor[frontLeft] = 127;
    	motor[rearRight] = 127;
    }
    if(rcvChar == 9) {
    	drive(0,0,0);
    }
    if(rcvChar == 10) { //strafe right
    	drive(0,0,127);
    }
    if(rcvChar == 11) { //strafe left
    	drive(0,0,-127);
    }
    if(rcvChar == 12) {
    	//motor[theArm] = 63;
    	pidRequestedValue=pidRequestedValue-100;
    	if(pidRequestedValue < -1200) {
    		pidRequestedValue = -1200;
    	}
    }
    if(rcvChar == 13) {
    	pidRequestedValue=pidRequestedValue+100;
    	if(pidRequestedValue > 0) {
    		pidRequestedValue = 0;
    	}
    	//motor[theArm] = -63;
    }
    if(rcvChar == 14) {
    	//motor[theArm] = 0;
    }
    if(rcvChar == 15) {
    	motor[theClaw] = 63;
    }
    if(rcvChar == 16) {
    	motor[theClaw] = -63;
    }
    if(rcvChar == 25) {
    	motor[theClaw] = -30;
    }
    if(rcvChar == 17) {
    	motor[theClaw] = 0;
    }
    if(rcvChar == 18) {
    	pidRequestedValue = 30;
    }
    if(rcvChar == 19) {
    	pidRequestedValue = 60;
    }
    if(rcvChar == 20) {
    	pidRequestedValue = 90;
    }
    if(rcvChar == 21) {
    	pidRequestedValue = 0;
    }
    if(rcvChar == 255) {
    	rcvChar = getChar(uartOne);
    	while(rcvChar == -1) {
      	wait1Msec(2);
      	rcvChar = getChar(uartOne);
    	}
    	btx = map(rcvChar,0,200,-127,127);
    	rcvChar = getChar(uartOne);
    	while(rcvChar == -1) {
      	wait1Msec(2);
      	rcvChar = getChar(uartOne);
    	}
    	bty = map(rcvChar,0,200,127,-127);
    	rcvChar = getChar(uartOne);
    	while(rcvChar == -1) {
      	wait1Msec(2);
      	rcvChar = getChar(uartOne);
    	}
    	btx2 = map(rcvChar,0,200,-127,127);
    	rcvChar = getChar(uartOne);
    	while(rcvChar == -1) {
      	wait1Msec(2);
      	rcvChar = getChar(uartOne);
    	}
    	bty2 = map(rcvChar,0,200,127,-127);
    	drive(bty,btx2,btx);
    	rcvChar = getChar(uartOne);
    	while(rcvChar == -1) {
      	wait1Msec(2);
      	rcvChar = getChar(uartOne);
    	}
    	int armValue = rcvChar;
    	rcvChar = getChar(uartOne);
    	while(rcvChar == -1) {
      	wait1Msec(2);
      	rcvChar = getChar(uartOne);
    	}
    	int clawValue = rcvChar;
    	clawValue = map(clawValue,0,254,-127,127);
    	motor[theClaw] = clawValue;
    	pidRequestedValue = map(armValue,0,100,0,-1200);
    }
	}
}
